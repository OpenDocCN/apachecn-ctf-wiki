<!--yml
category: 未分类
date: 2022-04-26 14:50:58
-->

# BUUCTF RSA2&RSA3 解题思路及公式推导_拔草能手晓寒的博客-CSDN博客_buuctf rsa

> 来源：[https://blog.csdn.net/xiao_han_a/article/details/118557541](https://blog.csdn.net/xiao_han_a/article/details/118557541)

# RSA2

## 题目

e = 65537

n=248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113

dp=905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657

c=140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751

## 解题思路

题目给出了e，n，dp，c，求解明文

常规的思路是将n分解为p和q，但是这里给的n有309位之长，直接爆破求解显然难度很大

可以关注到题目所给的dp，看一下这个dp怎么用

进行一下公式推导：

dp = d % (p-1) ①

d = dp + k1 * (p-1) ②

d * e = 1 + k2(p-1)(q-1) ③

把②代入③，得到

e * (dp + k1(p-1)) = 1 + k2(p-1)(q-1)

为把系数k消掉，两边同时对(p-1)取模

e * dp % (p - 1) = 1

e * dp = 1 + k(p - 1)

由③就可以导出p与e、dp的关系

**p - 1 = (e * dp - 1) / k** ④

但是这里引入了一个系数k，这个k该怎么处理呢

④变形一下有

k = (e * dp - 1) / (p-1)

又由①，可以判断出dp < (p-1)

所以可以得到k = (e * dp - 1) / (p-1) < e

e = 65537，因此k的范围有了约束

至此，根据④式可以求解p

具体思路如下：

*   1.遍历k，k的范围是(1-65537)

*   2.判断(e * dp - 1)能否整除k，若能，则p = (e * dp - 1) / k + 1

*   3.判断n能否整除p，若能，则q = n / p

*   4.判断p，q是否都为素数，若都通过素性检验，则n成功分解出p和q

*   5.有了p、q之后，就可以计算出私钥d，进行解密得到flag

附上代码：

```
import gmpy2
import  binascii

e = 65537
n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113
dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657
​
c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751

tmp = e * dp -1
#根据联立条件有: e*dp = 1 + k(p-1)，故求解p的式子为：(p-1) = (e*dp-1) / k
for k in range(1, e):#因为K上限只到e，故遍历求解
    if tmp % k == 0:#验证(p-1)是否为整除结果
        p = (tmp // k) + 1
        if n % p == 0:#验证p能否被n整除
            q = n // p
            if gmpy2.is_prime(p) and gmpy2.is_prime(q):#验证求解的p, q是否为素数
               # print(k)
                print("N的分解结果为 : ")
                print("%d = %d * %d" % (n, p, q))
                break
​
d = gmpy2.invert(e,(p-1)*(q-1)) # 求逆元，de = 1 mod fai(n)
m = gmpy2.powmod(c,d,n)# 幂取模，求明文
​
m = hex(m)[2:]     
print("密文数据为：0x" + m)
flag = binascii.unhexlify(m)
print(flag)
```

## flag

flag{wow_leaking_dp_breaks_rsa?_98924743502}

# RSA3

## 题目

c1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361

n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801

e1=11187289

c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397

e2=9647291

## 解题思路

已知n，e1，c1，e2，c2，求解明文

这道题思路比较清晰，很明显要采用共模攻击

共模攻击是指生成秘钥的过程中使用了相同的模数n，此时用不同的秘钥e1，e2加密同一信息m，得到不同的密文c1，c2，即

m^e1 % n = c1

m^e2 % n = c2

因为e1和e2都是素数，所以由扩展欧几里得算法

可以计算出s1和s2，使得e1 * s1 + e2 * s2 = 1

根据这些信息，可以直接计算m

公式推导如下：

m = m % n

m = m1 % n

m = m^(e1*s1+e2*s2) % n

m = (m^(e1*s1) % n * m^(e2*s1) % n) % n

m = (c1^s1 % n * c2^s2 % n) % n

附上代码：

```
import gmpy2
import  binascii

c1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361
n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801
e1=11187289
c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397
e2=9647291
​
#扩展欧几里得算法
#return (r,x,y) 其中，r为a和b的最大公约数，xy满足ax + by = 1
r, s1, s2 = gmpy2.gcdext(e1, e2)    #计算s1，s2
m = (gmpy2.powmod(c1,s1,n)*gmpy2.powmod(c2,s2,n)) % n   #计算明文m
​
m = hex(m)[2:]
print("明文数据为：0x" + m)
flag = binascii.unhexlify(m)
print(flag)
```

## flag

flag{49d91077a1abcb14f1a9d546c80be9ef}